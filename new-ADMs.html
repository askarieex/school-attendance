<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Definitive Guide: ZKTeco K40 Pro & MERN Backend Integration</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: #f8fafc; color: #1e293b; line-height: 1.7; padding: 40px; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 50px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.08); }
        h1, h2, h3, h4 { color: #1e293b; font-weight: 700; margin-top: 1.5em; margin-bottom: 0.8em; }
        h1 { font-size: 2.8rem; text-align: center; border-bottom: 4px solid #3b82f6; padding-bottom: 20px; margin-bottom: 40px; }
        h2 { font-size: 2rem; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.2rem; color: #3b82f6; }
        p { margin-bottom: 1rem; }
        code { background: #eef2ff; color: #4338ca; padding: 4px 8px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.95rem; }
        pre { background: #1e293b; color: #e2e8f0; padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.9rem; overflow-x: auto; margin: 20px 0; }
        .info-box { background: #eff6ff; border-left: 5px solid #3b82f6; padding: 20px; border-radius: 8px; margin: 25px 0; }
        .info-box.success { background: #f0fdf4; border-color: #10b981; }
        .info-box.danger { background: #fef2f2; border-color: #ef4444; }
        .info-box.warning { background: #fffbeb; border-color: #f59e0b; }
        table { width: 100%; border-collapse: collapse; margin: 25px 0; }
        th, td { border: 1px solid #e2e8f0; padding: 15px; text-align: left; }
        th { background: #f8fafc; font-weight: 600; }
        ul { padding-left: 20px; margin-bottom: 1rem; }
        li { margin-bottom: 0.5rem; }
        .question { font-weight: 600; color: #1e293b; margin-top: 20px; }
        .answer { padding-left: 20px; border-left: 3px solid #cbd5e1; margin-top: 5px; }
    </style>
</head>
<body>

    <div class="container">
        <h1>Definitive Guide to Building Your Attendance System</h1>
        
        <p class="lead" style="text-align: center; font-size: 1.2rem; color: #475569;">This document is your complete blueprint for integrating the <strong>ZKTeco K40 Pro</strong> with a custom <strong>MERN (Express.js) backend</strong> using the modern <strong>ADMS (Push) protocol</strong>. This is a safe and scalable architecture.</p>

        <section>
            <h2>Section 1: The Core Concept (Push vs. Pull)</h2>
            <p>The most important decision is how the machine communicates with your server. The research you found confirms there are two methods: an old, slow method ("Pull") and a modern, fast method ("Push"). For your real-time cloud system, the **Push method is the only correct choice**.</p>

            <div class="info-box danger">
                <h4>The Old Method: Pull Protocol (What We Are AVOIDING)</h4>
                <p>In this model, your server must constantly ask ("pull") the machine for new data. This is slow, not real-time, requires a complex local network setup (LAN/VPN), and cannot scale to many devices.</p>
            </div>

            <div class="info-box success">
                <h4>The Modern Method: Push Protocol / ADMS (What We ARE USING)</h4>
                <p>The device itself actively "pushes" attendance data to your server the moment an event happens. It also periodically "checks in" to pull commands from your server. This is fast, real-time, works over the standard internet, and is highly scalable. ZKTeco brands this feature as **ADMS**.</p>
            </div>
        </section>

        <section>
            <h2>Section 2: Hardware Setup (ZKTeco K40 Pro)</h2>
            <p>Your chosen machine, the **ZKTeco K40 Pro**, is the correct hardware because it supports the **ADMS protocol**. This allows it to connect directly to your cloud server (VPS) without needing a Raspberry Pi bridge.</p>

            <h3>Step-by-Step Configuration Guide</h3>
            <ol>
                <li><strong>Connect to Wi-Fi:</strong> In the device menu, go to <code>Comm. ‚Üí Wi-Fi</code> and connect the machine to the school's internet.</li>
                <li><strong>Configure ADMS Settings:</strong> This is the most important step.
                    <ul>
                        <li>Go to <code>Menu ‚Üí Comm. ‚Üí ADMS</code> (or "Cloud Server Settings").</li>
                        <li><strong>Server Address:</strong> Enter your server's public domain name or VPS IP address (e.g., <code>api.yourcompany.com</code>).</li>
                        <li><strong>Server Port:</strong> Enter <code>80</code> for standard HTTP or <code>443</code> for secure HTTPS.</li>
                    </ul>
                </li>
            </ol>
             <div class="info-box warning">
                <h4>Security: The Serial Number (SN)</h4>
                <p>The device authenticates with your server by sending its unique, factory-assigned **Serial Number** with every request. In your Super Admin Panel, you must register this SN and link it to a school. Your backend will reject any communication from an unregistered device.</p>
            </div>
        </section>

        <section>
            <h2>Section 3: Backend Architecture (Express.js)</h2>
            <p>Your backend must be ready to listen for the machine's communications. The K40 Pro's firmware is hardcoded to use specific endpoint names. You **must** create these exact endpoints in your Express.js app.</p>

            <h3>Endpoint 1: To Receive Logs (The "Push" Endpoint)</h3>
            <p>The machine will send attendance logs and other events here in real-time.</p>
            <ul>
                <li><strong>Endpoint Name:</strong> <code>POST /iclock/cdata</code></li>
                <li><strong>Function:</strong> Receives attendance logs, parses the raw text data, and saves them to your database.</li>
                <li><strong>Important:</strong> The data will arrive as plain text with fields separated by tabs, not as JSON. Your server must reply with the word <code>OK</code> to confirm receipt.</li>
            </ul>

            <h3>Endpoint 2: To Send Commands (The "Pull" Endpoint)</h3>
            <p>The machine will periodically contact this endpoint to ask if you have any new instructions for it.</p>
            <ul>
                <li><strong>Endpoint Name:</strong> <code>GET /iclock/getrequest</code></li>
                <li><strong>Function:</strong> Checks a command queue in your database for any pending tasks for that device (identified by its Serial Number). If a command exists, it sends it back in the response. If not, it just replies with <code>OK</code>.</li>
            </ul>

            <h4>Example Express.js Server Code:</h4>
            <pre><code>
const express = require('express');
const bodyParser = require('body-parser');
const app = express();
const PORT = 3000;

// Middleware to read the raw text data sent by the ZKTeco device
app.use(bodyParser.text({ type: '*/*' }));

// In a real application, this would be a database table.
// This is a simple in-memory queue for demonstration.
// Key: Device Serial Number, Value: Command String
let commandQueue = {}; 

// Endpoint 2: The device checks in here to get commands
app.get('/iclock/getrequest', (req, res) => {
  const deviceSerial = req.query.SN; // The device identifies itself with its Serial Number
  
  if (!deviceSerial) {
    return res.status(400).send('ERROR: Device Serial Number missing.');
  }

  console.log(`Received a check-in from device: ${deviceSerial}`);

  // Check if there's a command waiting for this specific device
  if (commandQueue[deviceSerial] && commandQueue[deviceSerial].length > 0) {
    const command = commandQueue[deviceSerial].shift(); // Get the first command from the queue
    console.log(`Sending command to device ${deviceSerial}: ${command}`);
    return res.send(command);
  }

  // If no commands are waiting, just reply with "OK"
  return res.send('OK');
});

// Endpoint 1: The device sends real-time attendance logs here
app.post('/iclock/cdata', (req, res) => {
  const deviceSerial = req.query.SN;
  console.log(`--- New Log Received from Device: ${deviceSerial} ---`);
  console.log('Raw Data:', req.body); 
  
  // Here, you would add your logic to parse the raw text and save it to your database.
  // For example: const logs = parseZkTecoLog(req.body);
  
  // You MUST reply with 'OK' so the machine knows the log was received successfully.
  res.send('OK');
});

// A simple example endpoint for your dashboard to add a command to the queue
app.post('/api/v1/queue-command', express.json(), (req, res) => {
    const { serialNumber, command } = req.body;
    if (!commandQueue[serialNumber]) {
        commandQueue[serialNumber] = [];
    }
    commandQueue[serialNumber].push(command);
    res.send(`Command queued for device ${serialNumber}.`);
});


// Start the server
app.listen(PORT, () => {
  console.log(`ADMS server is listening on port ${PORT}`);
});
            </code></pre>
        </section>

        <section>
            <h2>Section 4: Two-Way Communication in Detail</h2>
            <p>This system allows for full two-way communication. Here is how you will implement the bulk user import feature.</p>

            <h3>How to Bulk Import Students (Dashboard to Machine)</h3>
            <ol>
                <li><strong>Admin Uploads CSV:</strong> An admin uploads a CSV file of 500 students to your web dashboard.</li>
                <li><strong>Backend Creates Queue:</strong> Your backend saves the 500 students to your main database. It then creates 500 formatted "Add User" command strings and stores them in a command queue, linked to the school's device serial number.</li>
                <li><strong>Device Checks In:</strong> The K40 Pro automatically sends its periodic `GET` request to `/iclock/getrequest`.</li>
                <li><strong>Server Sends Command:</strong> Your server takes the first command from the queue and sends it back as the response.</li>
                <li><strong>Device Processes Command:</strong> The K40 Pro receives the command, adds the student to its internal memory, and confirms completion to the server on its next check-in.</li>
                <li><strong>Repeat:</strong> This process repeats automatically in the background until the queue is empty and all 500 students are synced to the physical machine.</li>
            </ol>
            
            <h4>Key Command Formats:</h4>
            <ul>
                <li><strong>Add/Update a User:</strong> <code>C:295:DATA UPDATE user Pin=101\tName=Ali Khan\tCard=1234567890</code></li>
                <li><strong>Delete a User:</strong> <code>C:337:DATA DELETE user Pin=101</code></li>
                <li><strong>Restart the Device:</strong> <code>C:1:Restart</code></li>
            </ul>
        </section>
        
        <section>
            <h2>Section 5: Complete Recap - All Your Questions Answered</h2>
            
            <h4>üîÅ Push Protocol & ADMS</h4>
            <p class="question">1. What is the Push (ADMS) protocol, and how is it different from the Pull protocol?</p>
            <p class="answer">The Push (ADMS) protocol is where the device actively sends data to your server in real-time. It's different from the Pull protocol, where your server has to constantly ask the machine for data, which is slow and not real-time.</p>

            <p class="question">2. Which two endpoints must your Express.js server expose to communicate with a ZKTeco device using ADMS?</p>
            <p class="answer">You must create <code>GET /iclock/getrequest</code> (for commands) and <code>POST /iclock/cdata</code> (for logs).</p>

            <p class="question">3. What type of request does the biometric device send to /iclock/getrequest?</p>
            <p class="answer">It sends an HTTP GET request.</p>

            <p class="question">4. What kind of response should the server return to /iclock/getrequest when there are no commands?</p>
            <p class="answer">A plain text response containing only the word <code>OK</code>.</p>
            
            <p class="question">5. When a user punches in on the device, which endpoint does the device call to send data to the server?</p>
            <p class="answer">It calls the <code>POST /iclock/cdata</code> endpoint.</p>

            <p class="question">6. What format does the biometric device use to send attendance data (POST body)?</p>
            <p class="answer">It uses plain text, with fields separated by tabs.</p>

            <p class="question">7. Can you send a command to add a user from your backend to the device using Push protocol? What does that command look like?</p>
            <p class="answer">Yes. The command looks like: <code>C:295:DATA UPDATE user Pin=101\tName=John Doe\tPrivilege=0</code>.</p>
            
            <p class="question">8. How does the device receive commands if the server never initiates any connection?</p>
            <p class="answer">The device receives commands by periodically calling the `/iclock/getrequest` endpoint itself. Your server sends the command back as the response to that request.</p>

            <p class="question">9. What port does Push protocol (HTTP ADMS) typically use? Can you use HTTPS?</p>
            <p class="answer">It typically uses port 80 for HTTP. Yes, you can and should use port 443 for HTTPS for secure communication.</p>

            <p class="question">10. Do you need an SDK (like zkemkeeper.dll) or Pull-based code (zkteco-js) to build a real-time cloud-based system with K40 Pro?</p>
            <p class="answer">No. For this modern Push-based system, you do not need those legacy SDKs or libraries.</p>

            <h4>‚öôÔ∏è Hardware, Setup & Configuration</h4>
            <p class="question">11. What menu option on the K40 Pro must be configured to point the device to your Express backend?</p>
            <p class="answer">The "Cloud Server Setting" (or ADMS) in the device's communication menu.</p>
            
            <p class="question">12. Can you use ZKTeco K40 Pro with a cloud server (e.g., AWS, DigitalOcean) for real-time attendance?</p>
            <p class="answer">Yes, the ADMS protocol is specifically designed for this purpose.</p>
            
            <p class="question">13. What needs to be stored in your backend to track and send commands to the correct device?</p>
            <p class="answer">You must store each device's unique Serial Number (SN) and associate it with a school.</p>
            
            <p class="question">14. How do you identify which device is calling your API (hint: SN or serial number)?</p>
            <p class="answer">The device includes its Serial Number as a query parameter in the URL, like <code>/iclock/getrequest?SN=DEVICE_SERIAL</code>.</p>

            <p class="question">15. What are the advantages of using Push protocol in a multi-office deployment compared to Pull?</p>
            <p class="answer">The advantages are network simplicity (no VPN needed), true real-time data, and superior scalability.</p>
            
            <h4>üì¶ Implementation & Backend</h4>
            <p class="question">16. What should your /iclock/getrequest endpoint return if there‚Äôs a pending Restart command for the device?</p>
            <p class="answer">It should return the plain text command string: <code>C:1:Restart</code>.</p>
            
            <p class="question">17. If you want to delete a user from the device, what is the command string format to send via GET response?</p>
            <p class="answer">The command format is: <code>C:337:DATA DELETE user Pin=101</code>.</p>

            <p class="question">18. How do you store and manage pending commands for each device in your backend?</p>
            <p class="answer">You should use a command queue system, likely a table in your database that links a command string to a specific device's serial number.</p>
            
            <p class="question">19. Is it possible to bulk-import users from your database to the device using ADMS commands?</p>
            <p class="answer">Yes. You queue multiple "Add User" commands in your backend, and the device processes them sequentially each time it checks in.</p>
            
            <p class="question">20. If you want to debug what your device is sending or requesting, what should you log in your Express.js app?</p>
            <p class="answer">You should log the full request: headers, query parameters (especially the SN), and the raw request body to see the exact data.</p>
            
        </section>

    </div>

</body>
</html>